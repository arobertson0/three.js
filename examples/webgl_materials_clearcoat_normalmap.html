<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - materials - clearcoat normal</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		#vt {
			display: none
		}

		#vt,
		#vt a {
			color: orange;
		}
	</style>
</head>

<body>
	<div id="info">
		<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl - materials - clearcoat normal
		demo.<br />
	</div>

	<script type="module">

		import * as THREE from '../build/three.module.js';
		import * as Nodes from './jsm/nodes/Nodes.js';

		import Stats from './jsm/libs/stats.module.js';

		import { GUI } from './jsm/libs/dat.gui.module.js';

		import { OrbitControls } from './jsm/controls/OrbitControls.js';

		const notVaried = [
			'color',
			'metalness',
			'roughness',
			'reflectivity',
			'clearCoat',
			'clearCoatRoughness',
		];

		const noVar = {
			legacy: () => { },
			node: () => { }
		};

		const clearCoatMapVariations =
		{
			legacy: (mat, matModel) => {
				mat.clearCoatNormalScale = matModel.clearCoatNormalScale;

				if (mat.clearCoatNormalMap !== matModel.clearCoatNormalMap) {

					mat.clearCoatNormalMap = matModel.clearCoatNormalMap;
					mat.needsUpdate = true;

				}
			},
			node: (nodeMat, nodes) => {
				nodeMat.clearCoatNormal = new Nodes.NormalMapNode(
					nodes.clearCoatNormalMap,
					nodes.clearCoatNormalScale
				);
			}
		};

		const mapVariation =
		{
			legacy: (mat, matModel) => {
				mat.normalScale = matModel.normalScale;

				if (mat.normalMap !== matModel.normalMap) {

					mat.normalMap = matModel.normalMap;
					mat.needsUpdate = true;

				}
			},
			node: (nodeMat, nodes) => {
				nodeMat.normal = new Nodes.NormalMapNode(
					nodes.normalMap,
					nodes.normalScale
				);
			}
		};

		const variationDescs = [];

		for (let x = 0; x < 2; x++) {

			for (let y = 0; y < 2; y++) {

				variationDescs.push(
					{

						pos: new THREE.Vector3(x - 0.5, y - 0.5, 0),
						selectors: [

							y ? mapVariation : noVar,
							x ? clearCoatMapVariations : noVar,

						]

					}

				);

			}

		}

		var textureUrls = {

				face: "models/gltf/LeePerrySmith/Infinite-Level_02_Tangent_SmoothUV.jpg",
				carbon: "textures/normals/CarbonFiber_normal.jpg",
				scratch: "textures/normals/Norml_Scratches.jpg",
				tentacle: "textures/nvidia_tentacle/tentacle_tangent_space.png",

		};

		new THREE.FontLoader().load(
			'fonts/gentilis_regular.typeface.json',
			font => new THREE.CubeTextureLoader().load(
				genCubeUrls('./textures/cube/Park2/', '.jpg'),
				cubeMap =>  loadTextures(
					textureUrls,
					textures => initVariationScenes(variationDescs, font, cubeMap, textures)
				)
			)
		);

		function initVariationScenes(variationDescs, font, cubeMap, textures) {

			const container = document.createElement('div');
			document.body.appendChild(container);

			const scene = new THREE.Scene();
			scene.background = cubeMap;

			const stats = new Stats();
			container.appendChild(stats.dom);

			const { camera, renderer } = initRendering(scene, container);

			const nodes = {

				color: new Nodes.ColorNode(),
				metalness: new Nodes.FloatNode(0.0),
				roughness: new Nodes.FloatNode(1.0),
				reflectivity: new Nodes.FloatNode(0.0),
				clearCoat: new Nodes.FloatNode(1.0),
				clearCoatRoughness: new Nodes.FloatNode(0.0),
				normalMap: new Nodes.TextureNode(textures.face),
				normalScale: new Nodes.Vector2Node(1.0, 1.0),
				clearCoatNormalMap: new Nodes.TextureNode(textures.tentacle),
				clearCoatNormalScale: new Nodes.Vector2Node(1.0, 1.0)

			};

			const primitives = initVariationPrimitives(scene, variationDescs, cubeMap, nodes);

			const particle = initLights(scene);

			const elements = {
				primitives,
				particle,
				stats,
				nodes,
			};

			const getMatModel = setupGui(textures);

			startAnim(elements, getMatModel, renderer, scene, camera);

		}

		function updateScene(elements, getMatModel) {

			elements.stats.update();

			const matModel = getMatModel();

			// Update node values
			for (var matElem in elements.nodes) {
				const node = elements.nodes[matElem];
				node.value = matModel[matElem];
			}

			// update primitives
			for (var primitive of elements.primitives) {

				if (matModel.useNodes) {
					if (primitive.mesh.material !== primitive.nodeMat) {
						primitive.mesh.material = primitive.nodeMat;
					}
				} else {
					if (primitive.mesh.material !== primitive.mat) {
						primitive.mesh.material = primitive.mat;
					}
				}

				primitive.mesh.rotation.y += 0.01;

				// Update legacy material
				for (var matElem of notVaried) {
					primitive.mat[matElem] = matModel[matElem];
				}

				// Update legacy material variation
				primitive.update(matModel);

			}

			var timer = Date.now() * 0.00025;
			elements.particle.position.x = Math.sin(timer * 7) * 3;
			elements.particle.position.y = Math.cos(timer * 5) * 4;
			elements.particle.position.z = Math.cos(timer * 3) * 5;
		}

		// 	function addLabel(name, location, fontSize) {

		// 		fontSize = fontSize | 20;
		// 		var textGeo = new THREE.TextBufferGeometry(name,
		// 			{

		// 				font: font,
		// 				size: fontSize,
		// 				height: 1,
		// 				curveSegments: 1

		// 			}
		// 		);

		// 		var textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
		// 		var textMesh = new THREE.Mesh(textGeo, textMaterial);

		// 		// Center the bounding box on the specified position w/ translation of -half diagonal
		// 		textGeo.computeBoundingBox();
		// 		var bb = textGeo.boundingBox.clone();
		// 		var displace = bb.max.sub(bb.min).divide(new THREE.Vector3(2, 2, 2));

		// 		textMesh.position.copy(location.sub(displace));
		// 		scene.add(textMesh);

		// 	}

		function initRendering(scene, container) {
			const camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 1, 10000);
			camera.position.z = 20;

			const renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);

			renderer.gammaInput = true;
			renderer.gammaOutput = true;

			new OrbitControls(camera, renderer.domElement);

			window.addEventListener(
				'resize',
				() => {

					var width = window.innerWidth;
					var height = window.innerHeight;

					camera.aspect = width / height;
					camera.updateProjectionMatrix();

					renderer.setSize(width, height);
				},
				false
			);

			container.appendChild(renderer.domElement);

			return { camera, renderer };
		};

		function genCubeUrls(path, format) {

			return [
				path + 'posx' + format, path + 'negx' + format,
				path + 'posy' + format, path + 'negy' + format,
				path + 'posz' + format, path + 'negz' + format
			];

		};

		function initVariationPrimitives(scene, variationDescs, cubeMap, nodes) {

			const primitives = [];

			const geometry = new THREE.SphereBufferGeometry(1, 64, 32);

			for (let variation of variationDescs) {


				const nodeMat = new Nodes.StandardNodeMaterial();
				nodeMat.color = nodes.color;
				nodeMat.environment = new Nodes.CubeTextureNode( cubeMap );

				for (var node of notVaried) {
					nodeMat[node] = nodes[node];
				}

				for (var selector of variation.selectors) {
					selector.node(nodeMat, nodes)
				};

				var color = (new THREE.Color()).setHSL(0,1,0.5);

				const mat = new THREE.MeshPhysicalMaterial( {
					envMap: cubeMap,
				} );

				const mesh = new THREE.Mesh(geometry, mat);
				mesh.position.copy(variation.pos.multiply(new THREE.Vector3(2.5, 2.5, 2.5)));
				scene.add(mesh);

				const primitive = {
					mesh,
					mat,
					nodeMat,
					update: (matModel) => {
						for (var selector of variation.selectors) {
							selector.legacy(mat, matModel)
						};
					}
				};

				primitives.push(primitive);
			}

			return primitives;

		}

		function initLights(scene) {


			var ambientLight = new THREE.AmbientLight(0x444444);
			scene.add(ambientLight);

			var pointLight = new THREE.PointLight(0xffffff, 1.25, 1000);
			const particleLight = new THREE.Mesh(new THREE.SphereBufferGeometry(0.05, 4, 4), new THREE.MeshBasicMaterial({ color: 0xffffff }));
			particleLight.add(pointLight);
			scene.add(particleLight);


			var directionalLight = new THREE.DirectionalLight(0xffffff);
			directionalLight.position.set(-1, 0.5, 1);
			scene.add(directionalLight);

			return particleLight;

		}

		function setupGui(textures) {

			const textureNames = [];

			for (var texture in textures) {
				textureNames.push(texture);
			}

			const guiControls = {
				useNodes: true,

				hue: 0.4,
				saturation: 0.75,
				luminosity: 0.10,

				metalness: 0.0,
				roughness: 0.5,
				reflectivity: 0.9,
				clearCoat: 0.66,
				clearCoatRoughness: 0.0,

				normalMap: "carbon",
				normalScale: 2.0,
				clearCoatNormalMap: "scratch",
				clearCoatNormalScale: 2.0,
			};


			var gui = new GUI();
			gui.add(guiControls, 'useNodes');
			{

				var colorGui = gui.addFolder('Color');
				colorGui.add(guiControls, 'hue', 0, 1, 0.01);
				colorGui.add(guiControls, 'saturation', 0, 1, 0.01);
				colorGui.add(guiControls, 'luminosity', 0, 0.33, 0.01);
				//colorGui.open();
			}
			{

				var materialGui = gui.addFolder('Physical Material');
				materialGui.add(guiControls, 'metalness', 0, 1, 0.01);
				materialGui.add(guiControls, 'roughness', 0, 1, 0.01);
				materialGui.add(guiControls, 'reflectivity', 0, 1, 0.01);
				materialGui.open();

			}

			{

				var clearCoatGui = gui.addFolder('ClearCoat');
				clearCoatGui.add(guiControls, 'clearCoat', 0, 1, 0.01);
				clearCoatGui.add(guiControls, 'clearCoatRoughness', 0, 1, 0.01);
				clearCoatGui.open();

			}

			{
				var normalGui = gui.addFolder('Normal Maps');
				normalGui.add(guiControls, 'normalMap', textureNames);
				normalGui.add(guiControls, 'normalScale', 0, 5, 0.01);
				normalGui.add(guiControls, 'clearCoatNormalMap', textureNames);
				normalGui.add(guiControls, 'clearCoatNormalScale', 0, 5, 0.01);
				normalGui.open();
			}

			gui.open();

			const controlTranslations = {

				color: (ctrl) => (new THREE.Color()).setHSL( ctrl.hue, ctrl.saturation, ctrl.luminosity ),
				normalMap: (ctrl) => textures[ctrl.normalMap],
				clearCoatNormalMap: (ctrl) => textures[ctrl.clearCoatNormalMap],
				normalScale: (ctrl) => new THREE.Vector2(ctrl.normalScale, ctrl.normalScale),
				clearCoatNormalScale: (ctrl) => new THREE.Vector2(ctrl.clearCoatNormalScale, ctrl.clearCoatNormalScale),

			}

			return () => {
				const matModel = {};

				for (let control in guiControls) {
					let val = guiControls[control];
					matModel[control] = val;

				}

				for(let translation in controlTranslations){

					matModel[translation] = controlTranslations[translation](guiControls);

				}

				return matModel;

			};
		}

		// Chains callbacks to load many textures simply
		function loadTextures(textures, onLoad){

			// Transfer texture urls to an array so we can index it
			var textureList = [];

			for(var text in textureUrls){

				textureList.push({ name: text, url: textureUrls[text]});

			}

			var loadedTex = {};

			var loader = new THREE.TextureLoader();

			doLoad(0);

			// Uses recursive callbacks to iteratively load textures
			function doLoad(index){

				if( textureList.length === index ){

					onLoad(loadedTex);

				}
				else {

					var curTex = textureList[index];

					loader.load(
						curTex.url,
						function ( texture ){

							loadedTex[curTex.name] = texture;
							doLoad(index+1);

						}

					)

				}

			}

		}

		function startAnim(elements, getMatModel, renderer, scene, camera) {

			function anim() {

				requestAnimationFrame(anim);
				updateScene(elements, getMatModel);
				renderer.render(scene, camera);
			}
			anim();
		}

	</script>
</body>

</html>